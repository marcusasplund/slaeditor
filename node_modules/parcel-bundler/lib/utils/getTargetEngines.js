'use strict';

/**
 * Loads target node and browser versions from the following locations:
 *   - package.json engines field
 *   - package.json browserslist field
 *   - browserslist or .browserslistrc files
 *   - .babelrc or .babelrc.js files with babel-preset-env
 */
let getTargetEngines = (() => {
  var _ref = _asyncToGenerator(function* (asset, path) {
    let targets = {};
    let pkg = yield asset.getConfig(['package.json'], { path });
    let engines = pkg && pkg.engines;
    let nodeVersion = engines && getMinSemver(engines.node);
    if (typeof nodeVersion === 'string') {
      targets.node = nodeVersion;
    }

    if (engines && (typeof engines.browsers === 'string' || Array.isArray(engines.browsers))) {
      targets.browsers = engines.browsers;
    } else if (pkg && pkg.browserslist) {
      targets.browsers = pkg.browserslist;
    } else {
      let browserslist = yield loadBrowserslist(asset, path);
      if (browserslist) {
        targets.browsers = browserslist;
      } else {
        let babelTargets = yield loadBabelrc(asset, path);
        Object.assign(targets, babelTargets);
      }
    }

    if (Object.keys(targets).length === 0) {
      return null;
    }

    if (targets.browsers) {
      targets.browsers = browserslist(targets.browsers).sort();
    }

    return targets;
  });

  return function getTargetEngines(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

let loadBrowserslist = (() => {
  var _ref2 = _asyncToGenerator(function* (asset, path) {
    let config = yield asset.getConfig(['browserslist', '.browserslistrc'], { path, load: false });
    if (config) {
      let browserslist = browserslist.readConfig(config);
      if (typeof browserslist === 'object' && !Array.isArray(browserslist)) {
        browserslist = browserslist[process.env.NODE_ENV];
      }

      return browserslist;
    }
  });

  return function loadBrowserslist(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
})();

let loadBabelrc = (() => {
  var _ref3 = _asyncToGenerator(function* (asset, path) {
    let config = yield asset.getConfig(['.babelrc', '.babelrc.js'], { path });
    if (config && config.presets) {
      let env = config.presets.find(function (plugin) {
        return Array.isArray(plugin) && plugin[0] === 'env' || plugin[0] === '@babel/env';
      });
      if (env && env[1].targets) {
        return env[1].targets;
      }
    }
  });

  return function loadBabelrc(_x5, _x6) {
    return _ref3.apply(this, arguments);
  };
})();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const browserslist = require('browserslist');
const semver = require('semver');

function getMinSemver(version) {
  try {
    let range = new semver.Range(version);
    let sorted = range.set.sort((a, b) => a[0].semver.compare(b[0].semver));
    return sorted[0][0].semver.version;
  } catch (err) {
    return null;
  }
}

module.exports = getTargetEngines;